<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Week 06: Monitors and Blocking Synchronisation &mdash; YSC4231 2021</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> YSC4231: Parallel, Concurrent and Distributed Programming
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">3. FAQ on Learning and Plagiarism</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC4231: Parallel, Concurrent and Distributed Programming</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Week 06: Monitors and Blocking Synchronisation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="week-06-monitors-and-blocking-synchronisation">
<h1>Week 06: Monitors and Blocking Synchronisation<a class="headerlink" href="#week-06-monitors-and-blocking-synchronisation" title="Permalink to this heading"></a></h1>
<p>In this chapter we will consider <strong>monitors</strong> — a mechanism for
<cite>blocking</cite> synchronisation of concurrently executing threads,
complementary to spin-locks, considered previously.</p>
<p>The code for this lecture is provided in branch <code class="docutils literal notranslate"><span class="pre">06-monitors</span></code>
(package <code class="docutils literal notranslate"><span class="pre">monitors</span></code>) of the <a class="reference external" href="https://github.com/ysc4231/lectures-2021/tree/06-monitors">accompanying repository</a>.</p>
<section id="when-spinning-isn-t-good-enough">
<h2>When Spinning isn’t Good Enough<a class="headerlink" href="#when-spinning-isn-t-good-enough" title="Permalink to this heading"></a></h2>
<p>Imagine the following artificial problem. We want to implement a
shared linearisable counter that is incremented by two concurrent
threads running in parallel with the following catch: one thread may
increment a counter if its value is <cite>even</cite>, and another thread can
increment it if its value is <cite>odd</cite>. Obviously, the threads should
“take turns” to implement such a functionality. This can be achieved
by using a combination of regular spin-locks and <code class="docutils literal notranslate"><span class="pre">while</span></code>-loops, as
shown in the code below:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">java</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nn">concurrent</span><span class="p">.</span><span class="nn">locks</span><span class="p">.</span><span class="nc">ReentrantLock</span>
<span class="k">import</span><span class="w"> </span><span class="nn">monitors</span><span class="p">.</span><span class="nc">Logging</span>
<span class="k">import</span><span class="w"> </span><span class="nn">util</span><span class="p">.</span><span class="nc">ThreadID</span>

<span class="k">object</span><span class="w"> </span><span class="nc">CountTTASLock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Step 1: take the lock</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 2: only do stuff if some condition holds, otherwise yield</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Step 1: take the lock</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 2: wait while counter is even</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">evenAdder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">oddAdder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">evenAdder</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">oddAdder</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="n">evenAdder</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">oddAdder</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">formatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">java</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="nc">NumberFormat</span><span class="p">.</span><span class="n">getIntegerInstance</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">TOTAL</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Total time:          </span><span class="si">${</span><span class="n">formatter</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t1</span><span class="p">)</span><span class="si">}</span><span class="s"> ms&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The two threads, instances of <code class="docutils literal notranslate"><span class="pre">AdderToEven</span></code> and <code class="docutils literal notranslate"><span class="pre">AdderToOdd</span></code>
correspondingly will be taking turns. Each time a thread takes a lock,
it checks if the counter is in the “suitable” position (even or odd,
correspondingly). If it is the case, it will proceed to increment it,
also increasing its iteration index <code class="docutils literal notranslate"><span class="pre">k</span></code>. Otherwise, it will pass the
turn by releasing the lock and keeping to “spin” on the condition <code class="docutils literal notranslate"><span class="pre">k</span>
<span class="pre">&lt;</span> <span class="pre">TOTAL</span> <span class="pre">/</span> <span class="pre">THREADS</span></code> of the outer loop.</p>
<p>While correct, this implementation is somewhat unintuitive. Not only
it requires us to take care of synchronisation, each thread should
also ensure that it doesn’t miss its turn, essentially performing
additional spinning. In the same time, by incrementing a shared
<code class="docutils literal notranslate"><span class="pre">counter</span></code>, each thread implicitly “sends a message” to another
thread, so that one could take its turn. Meanwhile the current thread,
which has just incremented, will be busy-waiting for its next turn.</p>
<p>Java Virtual Machine (and, hence, Scala) provides a convenient
alternative to spinning/busy-waiting — blocking synchronisation, or,
simply <code class="docutils literal notranslate"><span class="pre">waiting</span></code>. It is implemented on top of the corresponding OS
primitives and comes in the following form.</p>
<p>As a standard locking mechanism, Java provides the class
<code class="docutils literal notranslate"><span class="pre">ReentrantLock</span></code>. We have used its instances in the past. It is very
similar to the locks we’ve seen and implemented before with the only
difference that it can be acquired by the <cite>same</cite> thread several times
in succession (and will have to be released the same number of times).
One of the methods of <code class="docutils literal notranslate"><span class="pre">Reentrantlock</span></code>, called <code class="docutils literal notranslate"><span class="pre">newCondition</span></code>,
returns an instance of a class <code class="docutils literal notranslate"><span class="pre">Condition</span></code>, which allows for the
following functionality.</p>
<p>A <strong>condition</strong> (sometimes also called <strong>conditional variable</strong>) is a
mechanism, associated with a lock that allows a thread A to
“temporarily release it” without leaving the critical section. This is
done by thread A by calling a method <code class="docutils literal notranslate"><span class="pre">await()</span></code> on the condition
object associated with the corresponding lock. Once having released a
lock this way, the thread A becomes <cite>suspended</cite>: it does not spin, but
rather “sleeps” (the OS takes care of putting a thread to sleep and
waking it up later). What happens next is another thread (let’s call
it B) willing to acquire the lock gets access to the critical section
and may work with it. Also, while it is in the critical section , B
may call a method <code class="docutils literal notranslate"><span class="pre">signal()</span></code> on the same (shared) condition object.
This will have the following effect. Once B exits its critical section
(or calls <code class="docutils literal notranslate"><span class="pre">await()</span></code> on the condition), the thread A will wake up and
continues its working in the critical section.</p>
<p>Notice that at any point in time at most one thread has been active
in the critical section. Using conditional variables, we can
re-implement our turn-based incrementation as follows:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">CountSingleCondition</span><span class="w"> </span><span class="p">{</span><span class="w"></span>


<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Step 1: take the lock</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 2: wait while counter is not even</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cond</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 4: Release the other thread</span>
<span class="w">          </span><span class="n">cond</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cond</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">cond</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that both calls to <code class="docutils literal notranslate"><span class="pre">cond.wait()</span></code> by the threads are “wrapped”
into a loop, e.g., as follows:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cond</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This is important for the following two reasons:</p>
<ol class="loweralpha simple">
<li><p>Java specification allows a blocked (waiting) thread to be “woken
up spuriously” if no other thread is in the critical section now.
This, however, might not correspond to the configuration in which
a thread is supposed to run, hence it needs to first check an
application-specific condition (e.g., “is the counter now even”)
before it proceeds.</p></li>
<li><p>In the case if multiple threads are involved concurrently,
<code class="docutils literal notranslate"><span class="pre">signal()</span></code> will wake up one of them non-deterministically. In
this case, when a specific thread wakes up, the state might,
again, not be in the “right configuration”. Therefore the freshly
awoken thread will have to check if it actually should be awaken,
and otherwise go to sleep again.</p></li>
</ol>
<p>After having read this code, you might have the following additional
questions.</p>
<ul class="simple">
<li><p><strong>Question</strong>: What if we move <code class="docutils literal notranslate"><span class="pre">cond.signal()</span></code> before <code class="docutils literal notranslate"><span class="pre">counter</span> <span class="pre">=</span>
<span class="pre">counter</span> <span class="pre">+</span> <span class="pre">1</span></code>?</p></li>
<li><p><strong>Answer</strong>: This will be equivalent to the original code.
<code class="docutils literal notranslate"><span class="pre">cond.signal()</span></code> only awakes another thread when the current one
exists the critical section (i.e., calls <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> of the
corresponding lock) or calls <code class="docutils literal notranslate"><span class="pre">wait()</span></code> on the associated condition variable.</p></li>
<li><p><strong>Question</strong>: What if we remove <code class="docutils literal notranslate"><span class="pre">cond.signal()</span></code>?</p></li>
<li><p><strong>Answer</strong>: That will lead to a deadlock, as another thread, waiting
on a condition, might never wake up.</p></li>
<li><p><strong>Question</strong>: What happens if replace <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(counter</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0)</span></code>
by <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(counter</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0)</span></code>?</p></li>
<li><p><strong>Answer</strong>: Nothing particularly bad, but it’s better to re-check
the condition before proceeding.</p></li>
<li><p><strong>Question</strong>: What happens if we call <code class="docutils literal notranslate"><span class="pre">cond.signal()</span></code> or
<code class="docutils literal notranslate"><span class="pre">cond.await()</span></code> outside of the Critical Section marked by
<code class="docutils literal notranslate"><span class="pre">lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>?</p></li>
<li><p><strong>Answer</strong>: This is considered a run-time error, leading to an
<a class="reference external" href="https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalMonitorStateException.html">exception</a>.</p></li>
<li><p><strong>Question</strong>: Which thread is notified by <code class="docutils literal notranslate"><span class="pre">cond.signal()</span></code> in case
if we have multiple threads?</p></li>
<li><p><strong>Answer</strong>: You should assume that a thread to wake up is chosen
randomly of all threads currently waiting. If you want to awake all
of them you should use <code class="docutils literal notranslate"><span class="pre">cond.signalAll()</span></code>. In this case all awoken
threads will be competing for the lock, with only one of them
getting it, and others going back to wait.</p></li>
</ul>
<p>Together, a (reentrant) lock with a number of conditional variables,
allowing for this kind of wait-notify message-passing are referred to
as a <strong>monitor</strong> synchronisation mechanism. Monitors were first
suggested and described in <a class="reference external" href="https://www.classes.cs.uchicago.edu/archive/2019/winter/33100-1/papers/hoare-monitors.pdf">1973 paper by Sir Tony Hoare</a>
(the same Tony Hoare who invented QuickSort and program logics).</p>
<p>The following series of images demonstrates a possible scenario
involving a monitor.</p>
<p>On the image below, a thread B has successfully acquired the lock,
entering the critical section. It then called the method
<code class="docutils literal notranslate"><span class="pre">cond.await()</span></code> of a conditional variable, thus, transitioning to the
“waiting room” with threads that have been suspended during their CS.</p>
<a class="reference internal image-reference" href="_images/mon1.jpg"><img alt="_images/mon1.jpg" class="align-center" src="_images/mon1.jpg" style="width: 500px;" /></a>
<p>Next, thread C enters the critical section, calling
<code class="docutils literal notranslate"><span class="pre">cond.signaAll()</span></code> and then <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>. This prompts two waiting
threads, A and B, to wake up and compete for the lock again.</p>
<a class="reference internal image-reference" href="_images/mon2.jpg"><img alt="_images/mon2.jpg" class="align-center" src="_images/mon2.jpg" style="width: 500px;" /></a>
<p>In the same time thread D enters the competition, acquiring the lock,
sending both A and B to spin until D leaves the critical section,
thus, giving them again a chance to acquire the lock.</p>
<a class="reference internal image-reference" href="_images/mon3.jpg"><img alt="_images/mon3.jpg" class="align-center" src="_images/mon3.jpg" style="width: 500px;" /></a>
</section>
<section id="using-multiple-conditional-variables">
<h2>Using Multiple Conditional Variables<a class="headerlink" href="#using-multiple-conditional-variables" title="Permalink to this heading"></a></h2>
<p>We can restructure our implementation of turn-based counter, reducing
the amount of overhead necessary to acquire the lock, replacing it by
the waiting. For this, we are going to emit <cite>two</cite> condition variables
associated with the same Java lock. The resulting implementation is as
follows:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">CountMultipleConditions</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">condEven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">condOdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">()</span><span class="w"></span>


<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Step 1: take the lock</span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Repeat in cycle</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Step 2: wait while counter is not even</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">condEven</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 4: Release the other thread</span>
<span class="w">          </span><span class="n">condOdd</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Step 5: Release the lock</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">condOdd</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s">: now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">condEven</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the threads wait and signal on the two different continual
variables, <code class="docutils literal notranslate"><span class="pre">condEven</span></code> and <code class="docutils literal notranslate"><span class="pre">condOdd</span></code>. Nevertheless, this does not
violate mutual exclusion, as <code class="docutils literal notranslate"><span class="pre">await()</span></code> and <code class="docutils literal notranslate"><span class="pre">signal()</span></code> are still
associated with the same lock object. However, multiple condition
variables in this case make it slightly easier to reason about the
permissions of the specific thread: each thread waits on <cite>its own</cite>
conditional variable, while signals on the one of the other thread’s.</p>
</section>
<section id="synchronising-many-threads-with-monitors">
<h2>Synchronising Many Threads with Monitors<a class="headerlink" href="#synchronising-many-threads-with-monitors" title="Permalink to this heading"></a></h2>
<p>Above we mention an additional mechanism of a conditional variable for
waking up the threads: <code class="docutils literal notranslate"><span class="pre">signalAll()</span></code> and explain its specifics (it
might send some threads to spin) and difference with <code class="docutils literal notranslate"><span class="pre">signal()</span></code>. For
instance, consider the following code that works with multiple
even/odd incrementers synchronising them via <code class="docutils literal notranslate"><span class="pre">await()</span></code> / <code class="docutils literal notranslate"><span class="pre">signal()</span></code>:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">CountManyThreads</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">condEven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">condOdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Step 1: take the lock</span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Repeat in cycle</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Step 2: wait while counter is not even</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">condEven</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s"> (EvenAdder): now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Step 4: Signal some other threads</span>
<span class="w">          </span><span class="n">condOdd</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Step 5: Release the lock</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">condOdd</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s"> (OddAdder) : now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">condEven</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">odds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">odds</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">t</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">odds</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">TOTAL</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, of <code class="docutils literal notranslate"><span class="pre">signal()</span></code> we could have used <code class="docutils literal notranslate"><span class="pre">signallAll()</span></code>
without noticeable difference.</p>
</section>
<section id="intrinsic-java-monitors">
<h2>Intrinsic Java Monitors<a class="headerlink" href="#intrinsic-java-monitors" title="Permalink to this heading"></a></h2>
<p>Since the patterns of working with monitors by means of manipulating
associated locks and condition variables so common, Java/Scala embed
it into its object-oriented mode. Each object in these languages comes
instrumented with a monitor. Since objects in Scala/Java are main
units of data, this design choice aims to simplify synchronisation on
all data associated with a particular object. That is, different
objects would have different monitors associated with them, and hence,
may be unsynchronised.</p>
<p>We can now demystify the statement <code class="docutils literal notranslate"><span class="pre">o.syncrhonized</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> we’ve
seen before: it simply wraps the code inside <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> with
<code class="docutils literal notranslate"><span class="pre">lock();</span> <span class="pre">try</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">finally</span> <span class="pre">{</span> <span class="pre">unlock()</span> <span class="pre">}</span></code>, where the
locking/unlocking is done on the implicit lock associated with an
object <code class="docutils literal notranslate"><span class="pre">o</span></code>. Similarly, waiting/signalling on a (single) conditional
variable associated with an object is done by callling <code class="docutils literal notranslate"><span class="pre">o.wait()</span></code>,
and <code class="docutils literal notranslate"><span class="pre">o.notify()</span></code> and <code class="docutils literal notranslate"><span class="pre">o.notifyAll()</span></code>, correspondingly. Notice, the
names of these methods are different on purpose from those of
conditional variables so they would not be confused. We can implement
our counter example using Java, which provides special primitives for
monitor-based synchronisation:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">CountIntrinsicMonitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToEven</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Step 1: take the lock</span>
<span class="w">      </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="k">synchronized</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Repeat in cycle</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Step 2: wait while counter is not even</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// TODO: Notice: now it&#39;s `wait()` instead of `await()`</span>
<span class="w">            </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Step 3: Do useful stuff</span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s"> (EvenAdder): now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Step 4: Notify all other threads</span>
<span class="w">          </span><span class="c1">// TODO: Notice: now it&#39;s `notifyAll()` instead of `signalAll()`</span>
<span class="w">          </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="n">notifyAll</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">AdderToOdd</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Thread</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ThreadID</span><span class="p">.</span><span class="n">get</span><span class="w"></span>
<span class="w">      </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="k">synchronized</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">TOTAL</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">THREADS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Thread </span><span class="si">$</span><span class="n">i</span><span class="s"> (OddAdder) : now counter = </span><span class="si">$</span><span class="n">counter</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="nc">CountIntrinsicMonitor</span><span class="p">.</span><span class="n">notifyAll</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Question</strong>: Why does it work in the presence of just one
“conditional variable”?</p></li>
<li><p><strong>Answer</strong>: Because of <code class="docutils literal notranslate"><span class="pre">notifyAll()</span></code> that wakes up all threads,
allowing the “right ones” to proceed eventually.</p></li>
<li><p><strong>Question</strong>: Will it sill work if we replace <code class="docutils literal notranslate"><span class="pre">notifyAll()</span></code> by
<code class="docutils literal notranslate"><span class="pre">notify()</span></code>?</p></li>
<li><p><strong>Answer</strong>: Nom, it will deadlock, as the thread of the same
“parity” can be notified, and it won’t be able to proceed, hanging
on the <code class="docutils literal notranslate"><span class="pre">wait()</span></code> call.</p></li>
<li><p><strong>Question</strong>: Why couldn’t use <code class="docutils literal notranslate"><span class="pre">this.synchronized</span></code> instead?</p></li>
<li><p><strong>Answer</strong>: Called within a thread <code class="docutils literal notranslate"><span class="pre">this.synchronized</span></code> would refer
to the closest enclosing object, i.e., the thread instance itself.
Since those are different for different threads, the access to the
counter would not be synchronised. This is why we instead synchronise
via the monitor associated with the global singleton object
<code class="docutils literal notranslate"><span class="pre">CountIntrinsicMonitor</span></code>.</p></li>
</ul>
</section>
<section id="the-lost-wakeup-problem">
<h2>The Lost-Wakeup Problem<a class="headerlink" href="#the-lost-wakeup-problem" title="Permalink to this heading"></a></h2>
<p>Consider the following queue implementation that makes use of Java
monitors:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MonitorQueue</span><span class="p">[</span><span class="nc">T</span><span class="p">:</span><span class="w"> </span><span class="n">scala</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="nc">ClassTag</span><span class="p">](</span><span class="kd">val</span><span class="w"> </span><span class="n">capacity</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">java</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nn">concurrent</span><span class="p">.</span><span class="nn">locks</span><span class="p">.</span><span class="nc">ReentrantLock</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">notFull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">notEmpty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="n">capacity</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">  </span><span class="nd">@throws</span><span class="p">[</span><span class="nc">InterruptedException</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">items</span><span class="p">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">notFull</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">items</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">items</span><span class="p">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">notEmpty</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nd">@throws</span><span class="p">[</span><span class="nc">InterruptedException</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">deq</span><span class="p">():</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">notEmpty</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">items</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">items</span><span class="p">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">notFull</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This queue is a fine example of a concurrent blocking implementation:
it is empty, no all calls to <code class="docutils literal notranslate"><span class="pre">deq()</span></code> will be blocked until another
thread enqueues an element. Similarly, if it is full, <code class="docutils literal notranslate"><span class="pre">enq()</span></code> will
block.</p>
<p>What will happen if we replace <code class="docutils literal notranslate"><span class="pre">notEmpty.signal()</span></code> in <code class="docutils literal notranslate"><span class="pre">enq()</span></code> by
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(count</span> <span class="pre">==</span> <span class="pre">1)</span> <span class="pre">notEmpty.signal()</span></code>. Unfortunately, this will lead
to an incorrect behaviour. Imagine that thread C is about to enqueue
an element to an empty queue, while A and B are waiting because of
<code class="docutils literal notranslate"><span class="pre">nonEmpty.await()</span></code>. Executing <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(count</span> <span class="pre">==</span> <span class="pre">1)</span> <span class="pre">notEmpty.signal()</span></code>
will wake up one of them, let’s say A, but before it removes an
element another thread, say D, sill enqueue another one, this time
<cite>without</cite> calling <code class="docutils literal notranslate"><span class="pre">nonEmpty.signal()</span></code>. Thus, the queue will have two
elements, before A removes one, and the queue will be non-empty. Yet,
B will be still waiting. This mistake is known as the Lost-Wakeup
Problem, and it can be avoided in the following way:</p>
<ul class="simple">
<li><p>Signalling all threads waiting on a condition (via <code class="docutils literal notranslate"><span class="pre">signalAll()</span></code>
or <code class="docutils literal notranslate"><span class="pre">notifyAll()</span></code>), not just one.</p></li>
<li><p>Specify a timeout while waiting (both <code class="docutils literal notranslate"><span class="pre">await()</span></code> and <code class="docutils literal notranslate"><span class="pre">wait()</span></code>
take a number of nanoseconds to wait as an optional argument).</p></li>
</ul>
</section>
<section id="read-write-locking">
<h2>Read-Write Locking<a class="headerlink" href="#read-write-locking" title="Permalink to this heading"></a></h2>
<p>In many cases a shared resource can allow multiple threads that do not
modify it access it concurrently, but will require an exclusive access
for someone to make modifications. This pattern is known as
<cite>Readers-Writers</cite>:</p>
<ul class="simple">
<li><p>Only one writer can be modifying the resource exclusively</p></li>
<li><p>Many readers can observe it concurrently without requiring mutual
exclusion, as long as there is no write.</p></li>
</ul>
<p>The structure allowing for such an access is called <strong>Read-Write
Lock</strong>. It can be implemented using monitors as follows:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">java</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nn">concurrent</span><span class="p">.</span><span class="nc">TimeUnit</span>
<span class="k">import</span><span class="w"> </span><span class="nn">java</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nn">concurrent</span><span class="p">.</span><span class="nn">locks</span><span class="p">.{</span><span class="nc">Lock</span><span class="p">,</span><span class="w"> </span><span class="nc">ReadWriteLock</span><span class="p">,</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * @author Maurice Herlihy, Ilya Sergey</span>
<span class="cm">  */</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleReadWriteLock</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">ReadWriteLock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">readers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">myLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReentrantLock</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">myReadLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ReadLock</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">myWriteLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">WriteLock</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myLock</span><span class="p">.</span><span class="n">newCondition</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">readLock</span><span class="p">:</span><span class="w"> </span><span class="nc">Lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myReadLock</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">writeLock</span><span class="p">:</span><span class="w"> </span><span class="nc">Lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myWriteLock</span><span class="w"></span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">ReadLock</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Lock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">lock</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">myLock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">writer</span><span class="p">)</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">condition</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">case</span><span class="w"> </span><span class="n">e</span><span class="p">:</span><span class="w"> </span><span class="nc">InterruptedException</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">readers</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">myLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">unlock</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">myLock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">readers</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">readers</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">condition</span><span class="p">.</span><span class="n">signalAll</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="n">myLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">protected</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">WriteLock</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Lock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">lock</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">myLock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">readers</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">condition</span><span class="p">.</span><span class="n">await</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">case</span><span class="w"> </span><span class="n">e</span><span class="p">:</span><span class="w"> </span><span class="nc">InterruptedException</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="n">myLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">unlock</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">myLock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">        </span><span class="n">condition</span><span class="p">.</span><span class="n">signalAll</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">myLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that any reader using the instance of the <code class="docutils literal notranslate"><span class="pre">ReadLock</span></code> will be
blocked as long as a writer is present (which is indicated by a
boolean shared variable <code class="docutils literal notranslate"><span class="pre">writer</span></code>). Once available, the reader lock
will admit multiple readers, so the writers will have to wait on a
writer lock until the <code class="docutils literal notranslate"><span class="pre">condition</span></code> is notified by <code class="docutils literal notranslate"><span class="pre">ReadLock</span></code>’s
<code class="docutils literal notranslate"><span class="pre">unlock()</span></code>. A similar intuition is applied to the writer lock.
Notice that the <code class="docutils literal notranslate"><span class="pre">condition</span></code> does not distinguish between the roles
(readers/writers) — it is used to notify all threads currently
waiting. In principle, the lock can be improved by using two different
condition variables.</p>
</section>
<section id="when-should-we-use-monitors">
<h2>When Should We Use Monitors<a class="headerlink" href="#when-should-we-use-monitors" title="Permalink to this heading"></a></h2>
<p>Monitors (locks + conditional variables) are complementary to
spin-locks. An appropriate synchronisation mechanisms depends on the
use case:</p>
<ul class="simple">
<li><p>Spin-locks are good when the critical sections are small (in terms
of execution time), thus the spinning time will likely be small too.
The main “cost” of a spin-lock is the high usage of CPU cycles while
spinning, as well as added contention overhead. Thus, spinning makes
sense for a multiprocessor, if we expect a short waiting time.</p></li>
<li><p>Monitors should be used for fine-grained management of access to a
critical section, which is long. However, for small critical
sections, waking up a thread requires <cite>context switching</cite> by a
processor, which is also expensive. That is, waiting (blocking) is
preferable if we expect to wait for a long time before getting the
access to the critical section.</p></li>
</ul>
</section>
<section id="other-synchronisation-mechanisms">
<h2>Other Synchronisation Mechanisms<a class="headerlink" href="#other-synchronisation-mechanisms" title="Permalink to this heading"></a></h2>
<p>As of now, monitors (reentrant locks + condition variables) are one of
the most popular blocking synchronisation mechanisms. However, most of
the popular concurrent libraries (such as <code class="docutils literal notranslate"><span class="pre">java.util.concurrent</span></code> and
C’s <code class="docutils literal notranslate"><span class="pre">PThreads</span></code>) provide other synchronisation primitives. Those are
typically implemented as instructions by most of the common processors.</p>
<ul class="simple">
<li><p><strong>Semaphore</strong> is similar to a lock that admits <span class="math notranslate nohighlight">\(n \geq 1\)</span>
threads. Once the capacity is reached, the new incoming threads are
blocked. Semaphores were invented by Edsger Dijkstra (the same as in
Dijkstra’s algorithm) in 1963. An example of using a semaphore (in
Java) can be found, e.g., by <a class="reference external" href="https://www.mkyong.com/java/java-thread-mutex-and-semaphore-example/">this link</a>.</p></li>
<li><p><strong>Mutex</strong> is simply a semaphore with capacity 1. As such, it is
equivalent to a lock.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Ilya Sergey.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>